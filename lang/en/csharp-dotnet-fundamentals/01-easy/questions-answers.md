## Q1. What is the difference between **compile time** and **run time** in C#?

**Question:**  
Explain what **compile time** and **run time** mean in C#, and compare them with simple examples.

**Answer:**  
- **Compile time** → The phase when source code is checked and translated into IL (Intermediate Language). Errors like syntax mistakes or wrong method calls are caught here.  
- **Run time** → The phase when the program is actually executed by the CLR. Errors like dividing by zero or null reference exceptions happen here.  

**Comparison**

| Aspect          | Compile Time                          | Run Time                           |
|-----------------|---------------------------------------|-------------------------------------|
| Checked by      | Compiler (C# → IL)                    | CLR (when executing code)           |
| Typical errors  | Syntax error, type mismatch           | NullReferenceException, DivideByZero|
| When            | Before execution (build)              | During program execution            |

**Example — Compile-time error:**
```csharp
public class Demo
{
    public void Test()
    {
        int x = "hello"; // ❌ compile-time error (type mismatch)
    }
}
```
```csharp
public class Demo
{
    public void Test()
    {
        int a = 10, b = 0;
        int result = a / b; // ❌ run-time error (DivideByZeroException)
    }
}
```

## Q2. What is IL and how does the C# compiler work?

**Question:**  
What is **IL (Intermediate Language)** in .NET, and how does the C# compiler work to produce and execute a program?

**Answer:**  
- **IL (Intermediate Language)** → A low-level, CPU-independent set of instructions generated by the C# compiler. It’s also called **MSIL** or **CIL**.  
- The **C# compiler (csc.exe)** translates C# source code → **IL** → stored inside an **assembly (.dll or .exe)**.  
- At run time, the **CLR’s JIT compiler (Just-In-Time)** converts IL into **machine code** specific to the CPU and OS, then executes it.  

**Compilation steps in .NET:**
1. **C# code** (`.cs` files)  
2. Compiled into **IL** + metadata → stored in assemblies  
3. **JIT compiler** translates IL → native machine instructions  
4. CLR executes machine code and manages memory, GC, security, etc.  

**Example (C# code → IL):**
```csharp
public class Demo
{
    public int Add(int a, int b) => a + b;
}
```
```csharp
// Equivalent IL (simplified, viewable with ILDASM/ILSpy):
.class public auto ansi beforefieldinit Demo extends [System.Runtime]System.Object
{
    .method public hidebysig instance int32 Add(int32 a, int32 b) cil managed
    {
        .maxstack 2
        ldarg.1
        ldarg.2
        add
        ret
    }
}

```