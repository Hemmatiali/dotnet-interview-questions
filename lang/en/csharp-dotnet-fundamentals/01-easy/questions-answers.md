## Q1. What is the difference between **compile time** and **run time** in C#?

**Question:**  
Explain what **compile time** and **run time** mean in C#, and compare them with simple examples.

**Answer:**  
- **Compile time** → The phase when source code is checked and translated into IL (Intermediate Language). Errors like syntax mistakes or wrong method calls are caught here.  
- **Run time** → The phase when the program is actually executed by the CLR. Errors like dividing by zero or null reference exceptions happen here.  

**Comparison**

| Aspect          | Compile Time                          | Run Time                           |
|-----------------|---------------------------------------|-------------------------------------|
| Checked by      | Compiler (C# → IL)                    | CLR (when executing code)           |
| Typical errors  | Syntax error, type mismatch           | NullReferenceException, DivideByZero|
| When            | Before execution (build)              | During program execution            |

**Example — Compile-time error:**
```csharp
public class Demo
{
    public void Test()
    {
        int x = "hello"; // ❌ compile-time error (type mismatch)
    }
}
```
```csharp
public class Demo
{
    public void Test()
    {
        int a = 10, b = 0;
        int result = a / b; // ❌ run-time error (DivideByZeroException)
    }
}
```

## Q2. What is IL and how does the C# compiler work?

**Question:**  
What is **IL (Intermediate Language)** in .NET, and how does the C# compiler work to produce and execute a program?

**Answer:**  
- **IL (Intermediate Language)** → A low-level, CPU-independent set of instructions generated by the C# compiler. It’s also called **MSIL** or **CIL**.  
- The **C# compiler (csc.exe)** translates C# source code → **IL** → stored inside an **assembly (.dll or .exe)**.  
- At run time, the **CLR’s JIT compiler (Just-In-Time)** converts IL into **machine code** specific to the CPU and OS, then executes it.  

**Compilation steps in .NET:**
1. **C# code** (`.cs` files)  
2. Compiled into **IL** + metadata → stored in assemblies  
3. **JIT compiler** translates IL → native machine instructions  
4. CLR executes machine code and manages memory, GC, security, etc.  

**Example (C# code → IL):**
```csharp
public class Demo
{
    public int Add(int a, int b) => a + b;
}
```
```csharp
// Equivalent IL (simplified, viewable with ILDASM/ILSpy):
.class public auto ansi beforefieldinit Demo extends [System.Runtime]System.Object
{
    .method public hidebysig instance int32 Add(int32 a, int32 b) cil managed
    {
        .maxstack 2
        ldarg.1
        ldarg.2
        add
        ret
    }
}
```

## Q3. What is JIT and CLR in .NET?

**Question:**  
What are **JIT (Just-In-Time compiler)** and **CLR (Common Language Runtime)** in .NET, and how do they work together?

**Answer:**  
- **CLR (Common Language Runtime):**  
  - The execution engine of .NET.  
  - Manages memory (GC), type safety, exceptions, security, threading, and execution of code.  
  - Provides the runtime environment for IL code.  

- **JIT (Just-In-Time compiler):**  
  - A component of the CLR.  
  - Converts IL (Intermediate Language) into **native machine code** at run time, just before execution.  
  - Ensures the same IL assembly can run on different CPUs/OSes.  

**JIT Compilation Modes:**  
- **Normal JIT** → Compiles methods as they are called.  
- **Pre-JIT (NGen, ReadyToRun)** → Compiles the whole assembly to native ahead of time.  
- **Tiered JIT** (modern .NET) → Starts with fast compilation, then re-optimizes hot methods for performance.  

**Example Flow:**  
```text
C# Code  →  IL (by C# compiler)  →  JIT (by CLR)  →  Machine Code → Executed
```
```csharp
// Example — C# code compiled and executed with JIT:
public class Calculator
{
    public int Multiply(int a, int b) => a * b;
}

class Program
{
    static void Main()
    {
        var calc = new Calculator();
        Console.WriteLine(calc.Multiply(3, 4));
    }
}

//At build → IL is generated.
//At run → JIT compiles Multiply into native instructions the first time it’s called, then executes it.
```
